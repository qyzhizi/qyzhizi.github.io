<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>canny on log</title><link>/tags/canny/</link><description>Recent content in canny on log</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Fri, 07 Jul 2023 15:40:11 +0800</lastBuildDate><atom:link href="/tags/canny/rss.xml" rel="self" type="application/rss+xml"/><item><title>Canny算法中sobel算子padding的方式对极大值抑制的影响</title><link>/canny-algorithm-sobel-padding-influence-for-NonMaximumSuppression.html</link><pubDate>Fri, 07 Jul 2023 15:40:11 +0800</pubDate><guid>/canny-algorithm-sobel-padding-influence-for-NonMaximumSuppression.html</guid><description>&lt;p>在使用sobel算子计算梯度时，需要注意padding的方式，一般采用复制像素的padding方式，不能使用补零与反射的padding方式。
应为会影响后续极大值抑制时，边缘像素的去留。&lt;/p></description></item><item><title>解读canny算法opencl实现</title><link>/analyze-canny-algorithm-opencl-implemention.html</link><pubDate>Fri, 07 Jul 2023 15:04:16 +0800</pubDate><guid>/analyze-canny-algorithm-opencl-implemention.html</guid><description>&lt;p>在看完了canny 算法 c++ 实现细节以及完成 pytorch 版本的实现后，我在考虑如何对算法进行并行加速，我知道有opencl 加速 与 cuda 加速（pytorch api 可以实现），打算先考虑opencl 的加速。我之前已经知道 opencv 中是包含了对 opencl 的支持，我比较好奇如何使用 opencl 对 canny 算法的加速。在github 找到一个实现，虽然不是特别好，但是用了解 opencl 的使用还是可以的。&lt;/p></description></item><item><title>PyTorch 实现 Opencv Canny 算法</title><link>/pytorch-implement-opencv-canny-algorithm.html</link><pubDate>Tue, 04 Jul 2023 17:06:31 +0800</pubDate><guid>/pytorch-implement-opencv-canny-algorithm.html</guid><description>&lt;div style="text-align: center;">
&lt;img src="https://qyzhizi.cn/img/202307041413380.png" style="width: 50%;">
&lt;/div></description></item></channel></rss>